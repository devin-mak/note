# 整洁代码

- 不要因为项目的工期而写出混乱不堪的代码，然后想着有朝一日再回头清理，可以简单实现，但请别做的很简陋。
- 走得稳才能走得快。
- 整洁的代码只做一件事情。
  
# 有意义的命名

- 变量、函数或类的命名应该充分表述其作用或者存在的意义。
- 避免误导，例如使用 accountList 来指称一组账号，但其类型并非 List。
- 有意义的区分而非使用 a1, a2。
- 使用较有辨识度的命名。
- 避免让其他人猜测，明确才是王道。
- 类名、对象名应当是名称，方法名应当是动词。
- 给每个抽象概念选一个词并在使用该概念的地方使用该词，例如所有通过主键查询的方法名都为 getById。
- 别用双关语，例如使用 insert 表示通过实体插入数据并返回主键 id，那么如果通过实体插入但是返回影响条数的方法就不再适合命名为 insert，因为其在语义上不等价。
- 只有程序员才会阅读代码，那么使用技术相关命名更容易被看懂。例如使用 adapter 模式，命名使用 AccountAdapter 更容易被看懂。
- 添加有意义的语境，例如 User 对象有地址相关字段，那么建议在这些字段使用 address 前缀，当然，该场景更好的做法是创建一个 Address 的类。
- 不要添加没用的语境，例如在应用内，使用应用的简写当类的前缀。

# 函数

- 第一规则是短小，因为短小精悍。常见的做法是将逻辑分支中的代码抽取成一个函数，并给予良好的命名。
- 只做一件事。
- 每个函数一个抽象层级。
- 向下规划。自顶向下的代码结构，程序描述当前的抽象层级，并引用下一抽象层级。
- 避免三个及以上的参数。
- 不应该使用标识参数，例如传入 isTest。
- 想办法减少参数数量，例如将合适的参数改成成员变量。
- 将多个参数封装成类。
- 使用异常代替返回错误码
- 抽离 try/catch 代码块，且只做错误处理，所以函数应该以 try 语句开始，catch 语句结束。

# 格式

- 将没用关系的代码用换行符隔开，而关系密切的代码请让它们挨在一起，避免让关系密切的代码分散在不同的源文件中，变量声明应该尽可能靠近其使用位置。

# 错误处理

- 在使用可控异常时，要注意可能会破坏封装，衡量其成本与收益。
- 给出异常发生的环境说明。
- 打包第三方 API，捕获并翻译第三方抛出的异常。
- 定义常规流程，确认是否需要抛出异常。
- 避免返回 null 值。

# 边界

- 学习性测试，通过测试学习跟验证第三方代码。
- 边界上的代码需要清晰的分割和定义了期望的测试。

# 单元测试

- TDD。
- 保持测试代码的整洁。
- 每个测试函数的断言数量应该尽可能的少。
- 每个测试一个概念。
- FIRST：
  - 快速: 测试能够快速运行。
  - 独立：测试之间相互独立。
  - 可重复：测试应当可在任何环境中重复通过。
  - 自足验证：测试应该有明确的通过或失败标志。
  - 及时：测试应该及时编写。

# 类

- 类应该短小，通过权责衡量类的长短。
- 单一权责原则，类或模块应有且只有一条加以修改的理由。
- 系统应该由许多短小的类而不是少量巨大的类组成。
- 内聚，如果一个类中的每一个变量都被每个方法所使用，则该类具有最大的内聚性，内聚性高，意味着类中的方法个变量互相依赖，互相结合成一个逻辑整体。
- 依赖倒置原则，类应当依赖于抽象而非具体细节。

# 系统

- 将系统的构造与使用分开。
- 控制反转（IoC），一种框架层面的设计思想，将第二权责（次要的、非核心的职责）从对象中拿出去，转移到另外一个专注于此的对象中，从而遵循了单一权责原则，例如在不使用框架的情况下，我们写完单元测试后，需要编写运行单元测试的代码，例如 main 方法，这样可能导致需要关注像运行环境等其他的因素，所以我们引入了测试框架，将这部分控制权交给了框架，这样我们便可以将这部分与业务无关的逻辑抽离出去。
- 依赖注入(DI)是一个具体的编程技巧，是 IoC 的一种实现，依赖关系不再由组件自身负责创建和管理，而是由外部容器在组件创建的时候注入到组件中，简单的理解就是不在类内部创建依赖类对象，而是将依赖的类对象在外部创建好之后，通过构造函数、函数参数等方式传递（或注入）给类使用。
  
# 迭进

- 简单设计规则：
  - 运行所有测试。
  - 不可重复。
  - 表达了程序员的意图。
  - 尽可能减少类和方法的数量。
  - 以上规则按其重要程度排列。

# 并发编程

- 并发是一种解耦策略，将目的与时机分解开。
- 分离并发相关代码与其他代码。
- 限制数据作用域。谨记数据封装，严格限制对可能被共享的数据的访问。
- 使用数据复本，避免共享数据。
- 线程应该尽可能的独立，不与其他线程共享数据，尝试将数据分解到可被独立线程操作的独立子集。
- 基础定义：
  - 限定资源：并发环境中有着固定尺寸或者数量的资源。例如数据库连接、固定尺寸读/写缓存等。
  - 互斥线程：每一时刻仅有一个线程能访问共享数据或者资源。
  - 线程饥饿：一个或一组线程在很长时间内或永久被禁止。例如总是让执行得很快的线程先运行，假如执行得快的线程没完没了，则执行时间长的线程就会挨饿。
  - 死锁：两个或多个线程相互等待执行结果。每个线程都在拥有其他线程需要的资源，得不到其他线程拥有的资源，旧无法终止。
  - 活锁：执行次序一致的线程，每次都想要起步，但发现其他线程已经在路上。由于竞争的原因，线程会持续尝试起步，但是在很长一段时间内无法如愿，甚至永远都无法启动。
- 并发编程常用的执行模型：
  - 生产者-消费者模型。
  - 读者-作者模型。
  - 宴席哲学家。
- 警惕同步方法之间的依赖。避免使用一个共享对象的多个方法，针对这一情况有三种手段：
  - 基于客户端的锁定：客户端代码在调用第一个方法前锁定服务端，确保锁的范围覆盖了调用最后一个方法的代码。
  - 基于服务端的锁定：在服务端内创建锁定服务端的方法，调用所有方法，然后解锁。让客户端代码调用新方法。
  - 适配服务端：创建执行锁定的中间层。
- 保持同步区微小。